<!DOCTYPE html>
<html>
<head>
<title>wordcount.c</title>
<link href="bootstrap/css/bootstrap.css" rel="stylesheet">
<link href="bootstrap/css/bootstrap-theme.css" rel="stylesheet">
<link href="css/index.css" rel="stylesheet">
<script src="bootstrap/js/bootstrap.js" type="text/javascript"></script>
<script src="js/jquery.min.js" type="text/javascript"></script>
<style>
    .source .hll { background-color: #ffffcc }
.source  { background: #f8f8f8; }
.source .c { color: #408080; font-style: italic } /* Comment */
.source .err { border: 1px solid #FF0000 } /* Error */
.source .k { color: #008000; font-weight: bold } /* Keyword */
.source .o { color: #666666 } /* Operator */
.source .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.source .cp { color: #BC7A00 } /* Comment.Preproc */
.source .c1 { color: #408080; font-style: italic } /* Comment.Single */
.source .cs { color: #408080; font-style: italic } /* Comment.Special */
.source .gd { color: #A00000 } /* Generic.Deleted */
.source .ge { font-style: italic } /* Generic.Emph */
.source .gr { color: #FF0000 } /* Generic.Error */
.source .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.source .gi { color: #00A000 } /* Generic.Inserted */
.source .go { color: #888888 } /* Generic.Output */
.source .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.source .gs { font-weight: bold } /* Generic.Strong */
.source .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.source .gt { color: #0044DD } /* Generic.Traceback */
.source .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.source .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.source .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.source .kp { color: #008000 } /* Keyword.Pseudo */
.source .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.source .kt { color: #B00040 } /* Keyword.Type */
.source .m { color: #666666 } /* Literal.Number */
.source .s { color: #BA2121 } /* Literal.String */
.source .na { color: #7D9029 } /* Name.Attribute */
.source .nb { color: #008000 } /* Name.Builtin */
.source .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.source .no { color: #880000 } /* Name.Constant */
.source .nd { color: #AA22FF } /* Name.Decorator */
.source .ni { color: #999999; font-weight: bold } /* Name.Entity */
.source .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.source .nf { color: #0000FF } /* Name.Function */
.source .nl { color: #A0A000 } /* Name.Label */
.source .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.source .nt { color: #008000; font-weight: bold } /* Name.Tag */
.source .nv { color: #19177C } /* Name.Variable */
.source .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.source .w { color: #bbbbbb } /* Text.Whitespace */
.source .mf { color: #666666 } /* Literal.Number.Float */
.source .mh { color: #666666 } /* Literal.Number.Hex */
.source .mi { color: #666666 } /* Literal.Number.Integer */
.source .mo { color: #666666 } /* Literal.Number.Oct */
.source .sb { color: #BA2121 } /* Literal.String.Backtick */
.source .sc { color: #BA2121 } /* Literal.String.Char */
.source .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.source .s2 { color: #BA2121 } /* Literal.String.Double */
.source .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.source .sh { color: #BA2121 } /* Literal.String.Heredoc */
.source .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.source .sx { color: #008000 } /* Literal.String.Other */
.source .sr { color: #BB6688 } /* Literal.String.Regex */
.source .s1 { color: #BA2121 } /* Literal.String.Single */
.source .ss { color: #19177C } /* Literal.String.Symbol */
.source .bp { color: #008000 } /* Name.Builtin.Pseudo */
.source .vc { color: #19177C } /* Name.Variable.Class */
.source .vg { color: #19177C } /* Name.Variable.Global */
.source .vi { color: #19177C } /* Name.Variable.Instance */
.source .il { color: #666666 } /* Literal.Number.Integer.Long */
</style>

    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-48664735-1', 'kylelk.github.io');
    ga('send', 'pageview');

    </script>
	</head>
<body>
<nav class="navbar navbar-default" role="navigation">
   <div class="navbar-header">
      <a class="navbar-brand" href="#">Kyle Kersey</a>
   </div>
   <div>
      <ul class="nav navbar-nav">
         <li><a href="code/">Code</a></li>
         <li><a href="about/">About</a></li>
          <li><a href="contact/">Contact</a></li>
          <li><a href="work/">Work</a></li>
          <li><a href="">Site Map</a></li>
      </ul>
   </div>
</nav>
<div class="main-area">
    <b><a id="raw_link" href="raw/wordcount.c">View Raw</a></b>
    <br>    
    <table class="sourcetable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176</pre></div></td><td class="code"><div class="source"><pre><span class="cm">/*</span>
<span class="cm"> * wordcount.c</span>
<span class="cm"> *</span>
<span class="cm"> * A simple program to count the number of words, characters, and lines in one</span>
<span class="cm"> * or more text files specified on the command line. This particular</span>
<span class="cm"> * implementation uses two passes through the file, one to count words and the</span>
<span class="cm"> * other characters and lines.</span>
<span class="cm"> *</span>
<span class="cm"> * To build:</span>
<span class="cm"> * 		gcc -ansi -pedantic -o wordcount wordcount.c</span>
<span class="cm"> *</span>
<span class="cm"> * To run:</span>
<span class="cm"> * 		./wordcount &lt;name of files to check&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Paul Bonamy - 24 May 2011</span>
<span class="cm"> * Updated to show more variety - 25 October 2011</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;stdlib.h&gt; </span><span class="cm">/* exit lives here */</span><span class="cp"></span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;	</span><span class="cm">/* strncmp and strlen live here */</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Remember: argc will end up populated with the number of arguments seen</span>
<span class="cm">	 * (including the name of the executable) and argv will have the actual</span>
<span class="cm">	 * arguments as strings. argv[argv] will always have the value 0.</span>
<span class="cm">	 */</span>
	
	<span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span><span class="p">;</span>	<span class="cm">/* a file pointer on which to work. */</span>
	
	<span class="kt">char</span> <span class="n">word</span><span class="p">[</span><span class="mi">81</span><span class="p">];</span> 	<span class="cm">/* can store up to 80 chars with room for a null byte */</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* number of words in input */</span>
	<span class="kt">int</span> <span class="n">charCount</span><span class="p">;</span>	<span class="cm">/* number of characters in input */</span>
	<span class="kt">int</span> <span class="n">lineCount</span><span class="p">;</span>	<span class="cm">/* number of lines in input */</span>
	<span class="kt">int</span> <span class="n">lineLength</span><span class="p">;</span>	<span class="cm">/* number of characters on a single line */</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * check to make sure we actually got a reasonable number of arguments.</span>
<span class="cm">	 * argc is always at least 1, but we need at least 2 to give us the name</span>
<span class="cm">	 * of the program and at least one file to count.</span>
<span class="cm">	 */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* stderr is the standard error output,</span>
<span class="cm">		   and is a good place to send, well, errors */</span>
		<span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;No file specified. Exiting...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* exit kills the program with the given return value */</span>
	<span class="p">}</span>
	
	<span class="cm">/*</span>
<span class="cm">	 * this loop will run us through all of the files specified at the command</span>
<span class="cm">	 * line. note that i starts at 1 because argv[0] will be the name of the</span>
<span class="cm">	 * program, which is not a file we want to try and read in text mode</span>
<span class="cm">	 *</span>
<span class="cm">	 * We can use a while loop here since argv[argc] is guaranteed to be 0</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * zero out our counter variables. C allows chaining like this</span>
<span class="cm">		 * because the result of an assignment is effectively returned</span>
<span class="cm">		 * so it can be used for other things.</span>
<span class="cm">		 */</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">charCount</span> <span class="o">=</span> <span class="n">lineCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
		<span class="cm">/*</span>
<span class="cm">		 * this is the first pass. We&#39;ll use fscanf to read in a word at</span>
<span class="cm">		 * a time on this pass.</span>
<span class="cm">		 */</span>
		
		<span class="cm">/*</span>
<span class="cm">		 * fopen takes the name of a file (as a string) and a mode (read, in</span>
<span class="cm">		 * this case) and attempts to open the given file in the given mode.</span>
<span class="cm">		 *</span>
<span class="cm">		 * it will return either a pointer to a file stream, or NULL in the</span>
<span class="cm">		 * event of a failure of some sort.</span>
<span class="cm">		 *</span>
<span class="cm">		 * ALWAYS check the return value before trying to use the file pointer!</span>
<span class="cm">		 */</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
		
		<span class="cm">/* check to see if the file opened correctly. */</span>
		<span class="k">if</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		
			<span class="cm">/* loop until we hit the end of the file */</span>
		
			<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
				
				<span class="cm">/*</span>
<span class="cm">				 * EOF only gets set once you try to read past the end,</span>
<span class="cm">				 * so we can get into trouble if the file ends in whitespace.</span>
<span class="cm">				 *</span>
<span class="cm">				 * However, (f)scanf will return EOF if it hit the end of the</span>
<span class="cm">				 * file during a read, so we make sure that wasn&#39;t set before</span>
<span class="cm">				 * incrementing the count.</span>
<span class="cm">				 *</span>
<span class="cm">				 * Note: this will give inaccurate results if a single word</span>
<span class="cm">				 * exceeds 80 characters.</span>
<span class="cm">				 */</span>
				<span class="k">if</span><span class="p">(</span><span class="n">fscanf</span><span class="p">(</span><span class="n">fp</span><span class="p">,</span> <span class="s">&quot;%80s&quot;</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="o">!=</span> <span class="n">EOF</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">count</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* got a word, so increment count */</span>
				<span class="p">}</span>
			<span class="p">}</span>
		
		<span class="p">}</span>
		<span class="cm">/* close the file when you&#39;re done with it. */</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		
		
		<span class="cm">/*</span>
<span class="cm">		 * pass two: do line and character count. Note: there&#39;s no need</span>
<span class="cm">		 * to have two passes, but the single-pass version is left as an</span>
<span class="cm">		 * exercise to the reader.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note: This bit was added after class</span>
<span class="cm">		 */</span>
		<span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
		<span class="k">if</span><span class="p">(</span><span class="n">fp</span><span class="p">)</span> <span class="p">{</span>
		
			<span class="k">do</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * this time around, we&#39;ll use fgets to read a line at a time.</span>
<span class="cm">				 * Note that fgets will read until it encounters an EOL/EOF, or</span>
<span class="cm">				 * reads 80 characters, whichever comes first.</span>
<span class="cm">				 */</span>
				<span class="n">fgets</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="mi">81</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
				
				<span class="cm">/*</span>
<span class="cm">				 * figure out the number of characters in the line and</span>
<span class="cm">				 * update the character count</span>
<span class="cm">				 */</span>
				<span class="n">lineLength</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">word</span><span class="p">);</span>
				<span class="n">charCount</span> <span class="o">+=</span> <span class="n">lineLength</span><span class="p">;</span>
				
				<span class="cm">/*</span>
<span class="cm">				 * Note that, if a line is especially long, fgets won&#39;t</span>
<span class="cm">				 * read it all in one go. We have to deal with that if we</span>
<span class="cm">				 * want to get an accurate count.</span>
<span class="cm">				 */</span>
				<span class="k">if</span><span class="p">(</span><span class="n">lineLength</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * if there are less than 80 chars, total, we know</span>
<span class="cm">					 * fgets hit a newline (or EOF), so update the line count.</span>
<span class="cm">					 */</span>
					<span class="n">lineCount</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">else</span><span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * there&#39;s a special case where a line is exactly 80</span>
<span class="cm">					 * characters including a newline. If that&#39;s the case,</span>
<span class="cm">					 * increment the line count.</span>
<span class="cm">					 */</span>
					<span class="k">if</span><span class="p">(</span><span class="n">word</span><span class="p">[</span><span class="mi">79</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\n&#39;</span><span class="p">){</span>
						<span class="n">lineCount</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">feof</span><span class="p">(</span><span class="n">fp</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
		
		<span class="cm">/*</span>
<span class="cm">		 * Note: it&#39;s entirely possible there are edge causes that this</span>
<span class="cm">		 * code a) doesn&#39;t catch and b) doesn&#39;t know it doesn&#39;t catch</span>
<span class="cm">		 *</span>
<span class="cm">		 * Finding them are up to the reader.</span>
<span class="cm">		 */</span>
		
		<span class="cm">/* print a little report */</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s:</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\t</span><span class="s">%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">count</span><span class="p">,</span> <span class="n">charCount</span><span class="p">,</span> <span class="n">lineCount</span><span class="p">);</span>
		
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* done with all files, so we&#39;re done. return. */</span>	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table>
   <div class="page-links">
    <a href="https://twitter.com/share" class="twitter-share-button" data-url="http://kylelk.github.io/kylekersey/code/wordcount.c.html">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>   
   </div>
    <pre>
The MIT License (MIT)

Copyright (c) 2014 kyle kersey

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
    </pre>
</div>
</body>
</html>